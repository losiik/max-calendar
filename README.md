# Max Calendar

## Общее описание
Max Calendar - это современный сервис для планирования встреч и управления временем, интегрированный с MAX-ботом.
Он позволяет пользователям бронировать слоты, делиться календарём, получать напоминания, а также создавать события голосом или текстом.
Проект состоит из четырёх сервисов в одном репозитории: фронтенд на React (работает как MAX WebApp, деплой на GitHub Pages), backend на FastAPI, бот на MAX API и cron сервис, который запускает напоминания. Все сервисы общаются через REST API и используют PostgreSQL как основную БД.

## Основные возможности

Персональный календарь - создавай, редактируй и подтверждай встречи.

MAX-бот - управление календарём прямо из чата.

Шаринг - делись доступом к своему расписанию для внешнего бронирования.

Уведомления и напоминания - автоматические алерты о предстоящих событиях.

Голосовые и текстовые команды - добавляй встречи с помощью речи (Vosk ASR) или сообщений.

Поддержка часовых поясов - корректная работа слотов при разных timezone.

Гибкие настройки - настройка рабочего времени, длительности слотов, уведомлений и выходных.

## Архитектура

Пользователь взаимодействует с фронтом или через WebApp (открывается прямо из MAX) или через ссылку из бота. Фронт обращается к REST ручкам вида `/api/v1/*`, backend обрабатывает запросы, сохраняет данные в Postgres и, при необходимости, обращается к внешним API (например, Salute Jazz). Бот регистрирует пользователя и выдаёт ссылку на гостевой календарь. Cron сервис дергает backend, чтобы тот отправил напоминания. Архитектура backend построена слоями API - Facade - Service - Repository, что позволяет переиспользовать доменную логику между HTTP, ботом и cron.

### Backend архитектура
- FastAPI + async SQLAlchemy поверх PostgreSQL 16, миграции выполняются yoyo, а `database.py` даёт общее подключение и middleware для сессий.
- Слои `api` → `facade` → `services` → `repository` разделяют транспорт, координацию и работу с БД; сигналы (`signals.py`) позволяют реагировать на события (регистрация пользователя, создание слота) и переиспользовать сценарии cron/бота без дублирования.
- Интеграции с внешними системами вынесены в `client/` (например, Salute Jazz), а в `backend/README.md` описаны все зависимости (`requirements.txt`), детальная схема и необходимые настройки для запуска приложения.

### Frontend архитектура
- React + TypeScript + Vite, структура feature-sliced: `entities` (типизация и API), `features` (сценарии вроде бронирования и управления доступностью), `widgets`, `pages`, `providers`, `shared`.
- Zustand хранит локальные состояния, TanStack Query управляет запросами и кэшом, Tailwind и Max UI отвечают за визуал. `shared/lib/max-web-app.ts` инкапсулирует Telegram MAX WebApp (initData, haptics, закрытие), поэтому фронт безопасно работает внутри мессенджера.
- Детали запуска, переменные окружения и скрипты описаны в `frontend/README.md`.

## Docker и оркестрация

`docker-compose.yml` описывает четыре сервиса и Postgres:

- backend: собирается из `backend/Dockerfile`, запускает `uvicorn backend.main:app --host 0.0.0.0 --port 9090`.
- bot: образ из `max_bot/Dockerfile`, стартует `python -u max_bot/main.py`.
- cron: образ из `cron_job/Dockerfile`, каждую минуту вызывает `/api/v1/reminder/`.
- db: postgres:16 с volume `postgres_data`.

Данны еиз БД находятся в вольюме `postgres_data`, который примонтирован к `/var/lib/postgresql/data`. При необходимости сбросить базу достаточно удалить том `docker volume rm max-calendar_postgres_data` перед повторным `make build`.

Каждый сервис получает свою `.env`, указанную в `env_file`. Dockerfile всех python сервисов построены одинаково: базовый python:3.12, копирование репозитория, установка зависимостей из соответствующего `requirements.txt`, установка `PYTHONPATH`.

## Переменные окружения

Backend (`backend/.env`):  
DB_HOST, DB_PORT, DB_MAIN_DATABASE, DB_USER, DB_PASSWORD - настройки Postgres.  
MAX_API_KEY - токен бота, нужен для интеграции с MAX API.  
SBER_API_KEY - ключ для Salute Jazz.  
PORT - опциональный порт FastAPI (по умолчанию 9000).

Frontend (`frontend/.env.developmenе` или любой env для Vite):  
VITE_API_BASE_URL - адрес backend, обычно https://<домен>/api/v1. (string)
VITE_MAX_USER_ID - опциональная заглушка для запуска вне Max (number).
VITE_USE_MOCKS - использовать заглушки вместо запросов к бекенду (true/false).

Bot (`max_bot/.env`):  
MAX_API_KEY - токен MAX.  
BACKEND_URL - базовый URL backend, например `https://max.expalingpt.ru/`.  
BOT_URL - публичная ссылка на WebApp, чтобы собрать кнопку «Поделиться».

Cron (`cron_job/.env`):  
REMINDER_ALERT_URL - полный URL до `/api/v1/reminder/`. - URL для рассылки уведомлений перед встречей
REMINDER_DAILY_URL - полный URL да `/api/v1/reminder/daily_reminder/` - URL для рассылки ежедневных напоминаний 

## Makefile

- `make up` - поднять compose в фоне.  
- `make build` - пересобрать образы и запустить.  
- `make down` - остановить и удалить контейнеры.  
- `make restart` - перезапустить стек.  
- `make logs` - посмотреть логи всех сервисов.  
- `make ps` - вывести состояние контейнеров.  

## Локальный запуск через Docker (В ПРОДЕ НЕ БУДЕТ РАБОТАТЬ, так как сейчас все задеплоено на сервере)

1. Создайте файлы `.env` в `backend`, `max_bot`, `cron_job` с переменными из раздела выше.  
2. Заполните `postgres` значения в `docker-compose.yml`.  
3. Выполните `make build`. Compose скачает зависимости, применит миграции и поднимет все контейнеры.  
4. Backend будет доступен на `http://localhost:9090`, Swagger на `http://localhost:9090/docs`.  
5. Фронтенд можно запустить отдельно (`npm run dev`) и направить `VITE_API_BASE_URL` на `http://localhost:9090/api/v1` или продовый урл `https://max.expalingpt.ru/api/v1`.

## Запуск на сервере

Минимальная конфигурация - любой Linux с docker и docker compose plugin. Шаги:

1. Склонировать репозиторий на сервер.
2. Создать `.env` файлы и заполнить секреты.  
3. Выполнить `make build` или `docker compose up -d --build` или `make run-prod` - для запуска из под sudo.  
Фронтенд разворачивается отдельно как статика: `npm run build`, содержимое `frontend/dist` копируется в любой CDN или gh-pages или vercel.

## Деплой фронтенда

Рекомендованный способ деплоя на GitHub Pages:

1. В `frontend/package.json` добавляем поле `homepage`, указывая адрес будущей стартовой страницы:  
   `"homepage": "https://<аккаунт>.github.io/<репозиторий-страниц>/"`.
2. Создаём отдельный репозиторий на GitHub (например, `max-calendar-web`) и добавляем его как `git remote add`:  
   `git remote add pages git@github.com:<аккаунт>/max-calendar-web.git`.
3. В `package.json` убеждаемся, что скрипт `deploy` указывает на этот репозиторий и ветку `gh-pages`:  
   `"deploy": "gh-pages -d dist -r git@github.com:<аккаунт>/max-calendar-web.git -b gh-pages"`.
4. Выполняем `npm install`, затем `npm run build` и `npm run deploy`. Скрипт соберёт проект, скопирует `index.html` в `404.html` и запушит содержимое `dist` в ветку `gh-pages` указанного репозитория.
5. В настройках GitHub Pages для `max-calendar-web` выбираем ветку `gh-pages` и корень (`/`). Готовый фронт доступен по `https://<аккаунт>.github.io/<репозиторий-страниц>/`. Эту ссылку и подключаем к приложению в боте. Никаких сторонних доменов создавать не требуется.

## Документация по сервисам

- `backend/README.md` - устройство API, зависимости и запуск.  
- `frontend/README.md` - структура WebApp и инструкция по сборке.  
- `max_bot/README.md` - MAX бот и его конфигурация.  
- `cron_job/README.md` - сервис напоминаний.  

## Вклад участников

- **Автор идеи**: Сергей Клосеп + Сергей Анненков
- **Разработка backend**: Сергей Клосеп
- **Разработка frontend**: Сергей Анненков
- **Разработка cron**: Сергей Клосеп
- **Разработка max_bot**: Сергей Клосеп
- **Следил за правилами и соответствием регламенту**: Сергей Анненков
- **Тестирование**: Сергей Клосеп + Сергей Анненков


## Тестирование

1. Основные сценарии тестирования

| № | Функциональность                     | Сценарий                                                          | Ожидаемый результат                            | Фактический результат                            | Статус |
| - | ------------------------------------ | ----------------------------------------------------------------- | ---------------------------------------------- | ------------------------------------------------ |---------------|
| 1 | Регистрация и настройка пользователя | Пользователь создаёт профиль, задаёт рабочее время и часовой пояс | Настройки успешно сохраняются                  | Настройки сохранились                             | Выполнено      |
| 2 | Создание встречи вручную             | Пользователь создаёт слот через интерфейс                         | Встреча создаётся, не пересекается с другими   | Встреча сохранилась и не пересекается             | Выполнено      |
| 3 | Создание встречи через текст         | Сообщение: “Забронируй встречу завтра в 10:00”                    | Встреча создаётся в правильное время           | Бронирование прошло и время выставилось верно     | Выполнено      |
| 4 | Создание встречи через голос         | Голосовое сообщение с фразой “Создай встречу на завтра в 9 утра”   | Распознавание корректное, слот создаётся       | Непостоянное распознавание голоса        | Выполнено частично     |
| 5 | Проверка пересечения слотов          | Попытка создать встречу в занятое время                           | Возвращается ошибка 409 | Ошибка пересечения отдана, слот не создан         | Выполнено      |
| 6 | Уведомления                          | За N минут до встречи приходит уведомление                        | Уведомление получено вовремя                   | Нотификация пришла в ожидаемое время                      | Выполнено      |
| 7 | Шаринг календаря                     | Внешний пользователь открывает доступ по токену                   | Слоты отображаются с учётом часовых поясов     | Расписание открылось, преесечения с учетом локального UTC найдены и отображены корректно   | Выполнено      |
| 8 | Фильтрация по рабочим дням           | Запрос на нерабочий день                                          | Возвращается пустой список слотов              | Возвратился пустой массив без ошибок              | Выполнено      |
| 9 | Временные зоны                       | Пользователь с +3 делится календарём с пользователем +4           | Отображается корректное локальное время        | Время у обоих отображается с нужным смещением     | Выполнено      |

Все критичные сценарии отработали штатно, багов не обнаружено.

## Безопасность

- **Валидация через MAX WebApp:** фронтенд при первом входе и каждые 2 часа отправляет `init_data` в `PUT /users/`, backend проверяет подпись через hash из init_data и выдаёт JWT. Токен хранится в `localStorage`, автоматически обновляется заранее и добавляется в `Authorization: Bearer ...` на каждом запросе.
- **Авторизация** все методы API используют только заголовок `Authorization`.
- **Шаринг и гостевой просмотр:** чужой календарь доступен только по токену, выданному в боте.
- **Ограничение CORS:** настроена политика CORS, все запросы разрашены только с одного стороннего домена.
